## 调度算法（一）

1. 先来先服务

   ![](pictures/2.1.2.png)

   ![](pictures/2.1.1.png)

2. 短作业优先

   + 非抢占式的短作业优先

     ![](pictures/2.1.3.png)

   + 抢占式的短作业优先

     ![](pictures/2.1.4.png)

   ![](pictures/2.1.5.png)
   
   + FDFS算法在每次调度的时候选择一个等待时间最长的作业(进程)为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题
   + SJF算法是一个选择一个执行时间最短的作业为其服务，但是又是不考虑各个作业的等待时间，因此导致了长作业不友好的问题，甚至还会造成饥饿问题

3. 响应比时间
   + ![](pictures/2.1.6.png)
   + ![](pictures/2.1.7.png)

4. 这三种算法适用于**早期的批处理系统**

## 调度算法（二）

1. 时间片轮转-分时操作系统

   +  ![](pictures/2.2.1.png)
   +  ![](pictures/2.2.2.png)
   +  ![](pictures/2.2.3.png)
   + 如果时间片的大小太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为先来先服务算法，并且会增大进程响应时间。因此时间片太大
2. 优先级调度算法
   + ![](pictures/2.2.4.png)
   + ![](pictures/2.2.5.png)
   + ![](pictures/2.2.8.png)
3. 多级反馈队列调度算法
   + ![](pictures/2.2.6.png)
   + ![](pictures/2.2.7.png)

## 调度算法（三）

1. 多级队列调度算法

   ![](pictures/2.3.1.png)

## 进程同步、进程互斥

1. 进程同步
   + 异步：各并发执行的进程以各自独立的、不可预知的速度向前推进（两个或多个进程中交替执行指令，并且交替执行的顺序每次执行都不一样）
   + 同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系，进程间的直接制约关系就是源于它们之间的相互合作
2. 进程互斥
   + ![](pictures/2.4.1.png)
   + ![](pictures/2.4.2.png)
   + ![](pictures/2.4.3.png)

## 进程互斥的软件实现方法

1. 单标志法

   + ![](pictures/2.5.1.png)
2. 双标志先检查法

   + ![](pictures/2.5.2.png)
3. 双标志后检查法
   + ![](pictures/2.5.3.png)
4. Peterson算法
   + ![](pictures/2.5.4.png)
   + 谁最后做出的谦让，那么对方就会掌握主动权


## 进程互斥的硬件实现方法

1. 中断屏蔽方法

   + ![](pictures/2.6.1.png)

2. TestAndSet指令

   ![](pictures/2.6.2.png)

3. Swap指令(XCHG指令)

   ![](pictures/2.6.3.png)

## 互斥锁

![](pictures/2.7.1.png)

![](pictures/2.7.2.png)

## 信号量机制

1.  整型信号量

   ![](pictures/2.8.1.png)

2.  记录型信号量 

   ![](pictures/2.8.2.png)

## 用信号量实现进程互斥、同步

1. 实现互斥

   ![](pictures/2.9.1.png)

2. 实现同步

   ![](pictures/2.9.2.png)

   ![](pictures/2.9.3.png)

## 生产者-消费者问题

1. 问题分析

   ![](pictures/2.10.1.png)

2. 实现

   ![](pictures/2.10.2.png)

3. 能否改变P、V操作的顺序

   ![](pictures/2.10.3.png)

## 多生产者-多消费者问题

## 吸烟者问题

## 读者写者问题

## 哲学家问题

## 管程

## 死锁

### 预防死锁

### 避免死锁

### 检测与解除
